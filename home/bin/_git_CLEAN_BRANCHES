#!/bin/bash

# --- Configuration ---
CORE_EXCLUDES=("main" "master" "develop" "HEAD" "production")
EXTRA_EXCLUDES=("staging")
DELETE_PATTERNS=("feature-*" "bugfix-*" "tmp-*")

STAGING_SCRIPT="$HOME/git-cleanup.sh"
GREEN='\033[0;32m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

echo -e "${BOLD}Synchronizing with remotes...${NC}"
git fetch --all --prune > /dev/null 2>&1

# 1. Gather Branches
# Get the current branch name to protect it
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Gather Remote Branches (Filter out symbolic HEAD)
REMOTE_LIST=$(git branch -r | grep -v -- "->" | sed 's/^[ *]*//')

# Gather Local Branches
LOCAL_LIST=$(git branch | sed 's/^[ *]*//')

if [ -z "$REMOTE_LIST" ] && [ -z "$LOCAL_LIST" ]; then
    echo "No branches found."
    exit 0
fi

# 2. Build Checklist items
CHECKLIST_ITEMS=()

# Function to determine if a branch should be checked by default
get_status() {
    local name=$1
    # Protect current branch
    [[ "$name" == "$CURRENT_BRANCH" ]] && echo "off" && return
    
    # Check exact excludes
    for p in "${CORE_EXCLUDES[@]}" "${EXTRA_EXCLUDES[@]}"; do
        [[ "$name" == "$p" ]] && echo "off" && return
    done
    
    # Check delete patterns
    for p in "${DELETE_PATTERNS[@]}"; do
        local regex="^${p//\*/.*}$"
        [[ "$name" =~ $regex ]] && echo "on" && return
    done
    
    echo "on"
}

# Add Locals to list
while read -r line; do
    [ -z "$line" ] && continue
    STATUS=$(get_status "$line")
    DESC="[LOCAL]"
    [[ "$line" == "$CURRENT_BRANCH" ]] && DESC="[LOCAL] *CURRENT*"
    CHECKLIST_ITEMS+=("LOCAL:$line" "$DESC $line" "$STATUS")
done <<< "$LOCAL_LIST"

# Add Remotes to list
while read -r line; do
    [ -z "$line" ] && continue
    BRANCH_NAME_ONLY="${line#*/}"
    STATUS=$(get_status "$BRANCH_NAME_ONLY")
    CHECKLIST_ITEMS+=("REMOTE:$line" "[REMOTE] $line" "$STATUS")
done <<< "$REMOTE_LIST"

# 3. The TUI (whiptail)
DESC="INSTRUCTIONS:\n"
DESC+="  - [X] CHECKED:   Will be added to deletion script.\n"
DESC+="  - [ ] UNCHECKED: Will be ignored (kept).\n\n"
DESC+="Note: Asterisk patterns (e.g. 'feature-*') are checked by default.\n"
DESC+="Current branch ($CURRENT_BRANCH) is unchecked by default."

SELECTED=$(whiptail --title "Git Local & Remote Cleanup" \
    --checklist "$DESC" \
    25 100 15 \
    "${CHECKLIST_ITEMS[@]}" \
    3>&1 1>&2 2>&3)

if [ $? -ne 0 ]; then
    echo -e "\nOperation cancelled."
    exit 0
fi

# 4. Generate the Staging Script
echo "#!/bin/bash" > "$STAGING_SCRIPT"
echo "echo -e '${RED}${BOLD}Executing Deletions...${NC}'" >> "$STAGING_SCRIPT"
chmod +x "$STAGING_SCRIPT"

DELETION_COUNT=0
for item in $SELECTED; do
    # Remove quotes
    item=$(echo "$item" | sed "s/'//g; s/\"//g")
    TYPE="${item%%:*}"
    VALUE="${item#*:}"
    
    if [ "$TYPE" == "LOCAL" ]; then
        echo "echo -n 'Deleting local branch: $VALUE... '" >> "$STAGING_SCRIPT"
        # Using -D to force delete in case it hasn't been merged
        echo "git branch -D \"$VALUE\" && echo 'SUCCESS' || echo 'FAILED'" >> "$STAGING_SCRIPT"
    else
        REMOTE="${VALUE%%/*}"
        B_PATH="${VALUE#*/}"
        echo "echo -n 'Deleting remote branch: $B_PATH from $REMOTE... '" >> "$STAGING_SCRIPT"
        echo "git push \"$REMOTE\" --delete \"$B_PATH\" && echo 'SUCCESS' || echo 'FAILED'" >> "$STAGING_SCRIPT"
    fi
    ((DELETION_COUNT++))
done

# 5. Final Confirmation
clear
if [ "$DELETION_COUNT" -eq 0 ]; then
    echo "No branches selected."
    rm -f "$STAGING_SCRIPT"
    exit 0
fi

echo -e "${GREEN}${BOLD}STAGING SCRIPT GENERATED:${NC} $STAGING_SCRIPT"
echo "----------------------------------------------------------------------"
cat "$STAGING_SCRIPT"
echo "----------------------------------------------------------------------"
echo -e "\n${BOLD}Total: $DELETION_COUNT deletions (local and remote) queued.${NC}"
read -p "Execute script now? (y/N): " confirm

if [[ "$confirm" =~ ^[Yy]$ ]]; then
    bash "$STAGING_SCRIPT"
    echo -e "\n${GREEN}Done.${NC}"
else
    echo -e "\nCancelled. Script remains at $STAGING_SCRIPT"
fi
