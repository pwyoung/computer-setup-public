#!/bin/bash

# GOAL
# - Let the user create a script that will delete unwanted git branches

# ==============================================================================
# LOGIC SUMMARY:
# - HIDE:
#    - Exact matches in HIDE_LIST (never shown in UI).
# - When creating the UI, the code guesses at what to delete or keep.
#   - "DELETE": Branches merged to 'main' OR matching DELETE_PATTERNS (*).
#   - "KEEP":  Current branch OR matches in CORE_EXCLUDES (exact names).
# ==============================================================================

# --- Configuration ---
HIDE_LIST=("main" "master") # Branches to remove from the UI entirely

CORE_EXCLUDES=("HEAD" "develop" "production")
EXTRA_EXCLUDES=("staging")
#DELETE_PATTERNS=("feature-*" "bugfix-*" "tmp-*")
DELETE_PATTERNS=("tmp-*")

STAGING_SCRIPT="$HOME/git-cleanup-commands.sh"
GREEN='\033[0;32m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

echo -e "${BOLD}Step 1: Synchronizing with remotes...${NC}"
git fetch --all --prune > /dev/null 2>&1

# 1. Gather Context
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Identify merged status

MERGED_LOCAL=$(git branch --merged main | sed 's/^[ *]*//')
MERGED_REMOTE=$(git branch -r --merged main | sed 's/^[ *]*//')

# Gather branch lists
REMOTE_LIST=$(git branch -r | grep -v -- "->" | sed 's/^[ *]*//')
LOCAL_LIST=$(git branch | sed 's/^[ *]*//')

# 2. Status Logic Function
get_default_status() {
    local name=$1
    local is_merged=$2

    # PROTECT: Current and Core
    [[ "$name" == "$CURRENT_BRANCH" ]] && echo "off" && return
    for p in "${CORE_EXCLUDES[@]}" "${EXTRA_EXCLUDES[@]}"; do
        [[ "$name" == "$p" ]] && echo "off" && return
    done

    # DELETE: Merged or Pattern match
    [[ "$is_merged" == "true" ]] && echo "on" && return
    for p in "${DELETE_PATTERNS[@]}"; do
        local regex="^${p//\*/.*}$"
        [[ "$name" =~ $regex ]] && echo "on" && return
    done

    echo "off"
}

# 3. Hidden Filter Function
is_hidden() {
    local name=$1
    for h in "${HIDE_LIST[@]}"; do
        [[ "$name" == "$h" ]] && return 0 # Is hidden
    done
    return 1 # Not hidden
}

CHECKLIST_ITEMS=()

# 4. Build List: Locals
while read -r line; do
    [ -z "$line" ] && continue

    # SKIP if in HIDE_LIST
    is_hidden "$line" && continue

    IS_MERGED="false"
    [[ "$MERGED_LOCAL" == *"$line"* ]] && IS_MERGED="true"
    STATUS=$(get_default_status "$line" "$IS_MERGED")

    DESC="[LOCAL]"
    [[ "$IS_MERGED" == "true" ]] && DESC="[MERGED]"
    [[ "$line" == "$CURRENT_BRANCH" ]] && DESC="[CURRENT]"
    CHECKLIST_ITEMS+=("LOCAL:$line" "$DESC" "$STATUS")
done <<< "$LOCAL_LIST"

# 5. Build List: Remotes
while read -r line; do
    [ -z "$line" ] && continue
    BRANCH_NAME_ONLY="${line#*/}"

    # SKIP if in HIDE_LIST
    is_hidden "$BRANCH_NAME_ONLY" && continue

    IS_MERGED="false"
    [[ "$MERGED_REMOTE" == *"$line"* ]] && IS_MERGED="true"
    STATUS=$(get_default_status "$BRANCH_NAME_ONLY" "$IS_MERGED")

    DESC="[REMOTE]"
    [[ "$IS_MERGED" == "true" ]] && DESC="[REMOTE:MERGED]"
    CHECKLIST_ITEMS+=("REMOTE:$line" "$DESC $line" "$STATUS")
done <<< "$REMOTE_LIST"

# 6. The TUI
SELECTED=$(whiptail --title "Git Cleanup Pro" \
    --checklist "Checked [X] = Delete | Unchecked [ ] = Keep\nStaging script: $STAGING_SCRIPT" \
    25 110 15 \
    "${CHECKLIST_ITEMS[@]}" \
    3>&1 1>&2 2>&3)

[[ $? -ne 0 ]] && echo -e "\nCancelled." && exit 0

# 7. Generate Script
echo "#!/bin/bash" > "$STAGING_SCRIPT"
chmod +x "$STAGING_SCRIPT"

DELETION_COUNT=0
for item in $SELECTED; do
    item=$(echo "$item" | sed "s/'//g; s/\"//g")
    TYPE="${item%%:*}"
    VALUE="${item#*:}"

    if [ "$TYPE" == "LOCAL" ]; then
        echo "git branch -d \"$VALUE\" 2>/dev/null || git branch -D \"$VALUE\"" >> "$STAGING_SCRIPT"
    else
        echo "git push \"${VALUE%%/*}\" --delete \"${VALUE#*/}\"" >> "$STAGING_SCRIPT"
    fi
    ((DELETION_COUNT++))
done

# 8. Review
clear
[[ "$DELETION_COUNT" -eq 0 ]] && echo "No selections." && rm -f "$STAGING_SCRIPT" && exit 0

echo -e "${GREEN}STAGED COMMANDS:${NC} $STAGING_SCRIPT"
echo "---------------------------------------------------"
cat "$STAGING_SCRIPT"
echo "---------------------------------------------------"
read -p "Run these $DELETION_COUNT deletions? (y/N): " confirm

[[ "$confirm" =~ ^[Yy]$ ]] && bash "$STAGING_SCRIPT" || echo "Aborted."

